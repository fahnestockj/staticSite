<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Immutability and React! | Fahnestockj</title>
<meta name="keywords" content="" />
<meta name="description" content="What is it Mutability in Javascript refers to the ability to change the state of an object after its creation.
In Javascript some examples of immutable objects are language primitives. As the lowest atomic level of the language, primitives are immutable which allows easy comparison between values.
For example string primitives cannot be modified after they&rsquo;re created.
const string1 = &#39;foo&#39; string1.concat(&#39;bar&#39;) console.log(string1) //foo string1 is not actually modified by its method, instead it the method returns a new string with the concatenation complete.">
<meta name="author" content="">
<link rel="canonical" href="https://fahnestockj.com/posts/immutability/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js" integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93&#43;QdxBJM917LmaT3s9E="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://fahnestockj.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://fahnestockj.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://fahnestockj.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://fahnestockj.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://fahnestockj.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.101.0" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-215231859-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="Immutability and React!" />
<meta property="og:description" content="What is it Mutability in Javascript refers to the ability to change the state of an object after its creation.
In Javascript some examples of immutable objects are language primitives. As the lowest atomic level of the language, primitives are immutable which allows easy comparison between values.
For example string primitives cannot be modified after they&rsquo;re created.
const string1 = &#39;foo&#39; string1.concat(&#39;bar&#39;) console.log(string1) //foo string1 is not actually modified by its method, instead it the method returns a new string with the concatenation complete." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fahnestockj.com/posts/immutability/" /><meta property="og:image" content="https://fahnestockj.com/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-12T10:02:24-05:00" />
<meta property="article:modified_time" content="2022-02-12T10:02:24-05:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://fahnestockj.com/papermod-cover.png"/>

<meta name="twitter:title" content="Immutability and React!"/>
<meta name="twitter:description" content="What is it Mutability in Javascript refers to the ability to change the state of an object after its creation.
In Javascript some examples of immutable objects are language primitives. As the lowest atomic level of the language, primitives are immutable which allows easy comparison between values.
For example string primitives cannot be modified after they&rsquo;re created.
const string1 = &#39;foo&#39; string1.concat(&#39;bar&#39;) console.log(string1) //foo string1 is not actually modified by its method, instead it the method returns a new string with the concatenation complete."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://fahnestockj.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Immutability and React!",
      "item": "https://fahnestockj.com/posts/immutability/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Immutability and React!",
  "name": "Immutability and React!",
  "description": "What is it Mutability in Javascript refers to the ability to change the state of an object after its creation.\nIn Javascript some examples of immutable objects are language primitives. As the lowest atomic level of the language, primitives are immutable which allows easy comparison between values.\nFor example string primitives cannot be modified after they\u0026rsquo;re created.\nconst string1 = \u0026#39;foo\u0026#39; string1.concat(\u0026#39;bar\u0026#39;) console.log(string1) //foo string1 is not actually modified by its method, instead it the method returns a new string with the concatenation complete.",
  "keywords": [
    
  ],
  "articleBody": " What is it Mutability in Javascript refers to the ability to change the state of an object after its creation.\nIn Javascript some examples of immutable objects are language primitives. As the lowest atomic level of the language, primitives are immutable which allows easy comparison between values.\nFor example string primitives cannot be modified after theyâ€™re created.\nconst string1 = 'foo' string1.concat('bar') console.log(string1) //foo string1 is not actually modified by its method, instead it the method returns a new string with the concatenation complete.\nThis is in contrast with Arrays which are a mutable object in Javascript.\nconst array1 = ['foo'] array1.push('bar') console.log(array1) //['foo','bar'] Here the method modifies the original object rather than creating a new one.\nSo why are there so many popular packages and frameworks trying to enforce immutability into objects and arrays? (Redux, Immer, Immutable.js)\nAnd why should we enforce immutability if mutable objects are an essential part of Javascript?\nThe answer lies in the performance and simplifying benefits of enforcing immutability in some web apps.\nReference vs Value equality in Javascript const obj1 = { foo: 'foo' } const obj2 = { foo: 'foo' } console.log(obj1 === obj2) //false console.log(obj1.foo === obj2.foo) //true Strings in Javascript are immutable allowing for easy comparison of equality. Objects on the other hand are mutable with many properties to compare making checking equality more complicated.\nThe strict equality operator === performs an efficient shallow comparison which can compare primitives easily, but wonâ€™t try to dig into the properties of an object. Instead when applied to objects it only compares the reference of the object.\nObjects and Arrays are the only built in mutable objects in Javascript and both are compared by reference when used with a shallow equality operator.\nA deep equality check (value equality) for mutable objects and arrays require digging to the values within the object which can be a complex and inefficient operation. To solve this problem packages like Immer and Immutable.js have been written to enforce immutable data structures. These packages use optimization techniques like structural sharing to cut down on the inefficiency of creating copies of the objects.\nWhy do we care? React is one of the most prominent and performant frameworks in web development\nThe main benefits of React come from some sophisticated change detection to only update the DOM when it has to. React is unopinionated about whether you use mutable or immutable data however it can be better optimized using immutable data. React offers a PureComponent along with a shouldComponentUpdate() method which can be easily implemented with immutable data to greatly increase performance.\nPure components implement the shouldComponentUpdate() method with a shallow prop and state comparison to decide whether to re-render the component. This shallow comparison is all thatâ€™s needed to decide whether the data has changed since the immutable data will have a new reference if it changed.\nshouldComponentUpdate: function(nextProps, nextState){ return shallowCompare(this, nextProps, nextState) } function shallowCompare(instance, nextProps, nextState){ return (nextProps === instance.props \u0026\u0026 nextState === instance.state) } Clearly for React immutability is a net positive as in many ways it matches the way the framework thinks. Immutability can help keep an application architecture simple and make it easier to reason about however one size doesnâ€™t fit all.\nRedux is a frontend state management framework designed with immutable data in mind. It takes advantage of the shallow equality checking to offer benefits like simpler programming and debugging with a ~time traveling~ debugger. Redux performs state management similar to an event sourced system where state is controlled by events (redux calls them actions) fed into reducers (pure functions with no side effects.) Event sourcing is a larger discussion coming soon ðŸ¤Œ.\nImmutability can bring increased performance to your app, and leads to simpler programming and debugging, as data that never changes is easier to reason about than data that is free to be changed arbitrarily throughout your app.\n-Our god Dan Abramov\nThereâ€™s a lot of hype surrounding immutability which is dangerous as like everything it can introduce a lot of unnecessary complexity if misused. Itâ€™s important to consider some contrary views as well and consider if itâ€™s worth the tradeoffs.\n",
  "wordCount" : "690",
  "inLanguage": "en",
  "datePublished": "2022-02-12T10:02:24-05:00",
  "dateModified": "2022-02-12T10:02:24-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://fahnestockj.com/posts/immutability/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Fahnestockj",
    "logo": {
      "@type": "ImageObject",
      "url": "https://fahnestockj.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://fahnestockj.com" accesskey="h" title="Fahnestockj (Alt + H)">Fahnestockj</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://fahnestockj.com/posts" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://fahnestockj.com/projects" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://fahnestockj.com">Home</a>&nbsp;Â»&nbsp;<a href="https://fahnestockj.com/posts/">Posts</a></div>
    <h1 class="post-title">
      Immutability and React!
    </h1>
    <div class="post-meta"><span title='2022-02-12 10:02:24 -0500 EST'>February 12, 2022</span>&nbsp;Â·&nbsp;4 min

</div>
  </header> 
  <div class="post-content"><blockquote>
<h2 id="what-is-it">What is it<a hidden class="anchor" aria-hidden="true" href="#what-is-it">#</a></h2>
<p>Mutability in Javascript refers to the ability to change the state of an object after its creation.</p>
</blockquote>
<p>In Javascript some examples of immutable objects are language primitives. As the lowest atomic level of the language, primitives are immutable which allows easy comparison between values.</p>
<p>For example string primitives cannot be modified after they&rsquo;re created.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">string1</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;foo&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">string1</span>.<span style="color:#a6e22e">concat</span>(<span style="color:#e6db74">&#39;bar&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">string1</span>) <span style="color:#75715e">//foo
</span></span></span></code></pre></div><p><code>string1</code> is not actually modified by its method, instead it the method returns a new string with the concatenation complete.</p>
<p>This is in contrast with Arrays which are a mutable object in Javascript.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">array1</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;foo&#39;</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">array1</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#39;bar&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">array1</span>) <span style="color:#75715e">//[&#39;foo&#39;,&#39;bar&#39;]
</span></span></span></code></pre></div><p>Here the method modifies the original object rather than creating a new one.</p>
<p>So why are there so many popular packages and frameworks trying to enforce <strong>immutability</strong> into objects and arrays? (Redux, Immer, Immutable.js)</p>
<p>And why should we enforce immutability if mutable objects are an essential part of Javascript?</p>
<p>The answer lies in the performance and simplifying benefits of enforcing immutability in <strong>some</strong> web apps.</p>
<h3 id="reference-vs-value-equality-in-javascript">Reference vs Value equality in Javascript<a hidden class="anchor" aria-hidden="true" href="#reference-vs-value-equality-in-javascript">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj1</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">foo</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;foo&#39;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj2</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">foo</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;foo&#39;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">obj1</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">obj2</span>) <span style="color:#75715e">//false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">obj1</span>.<span style="color:#a6e22e">foo</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">obj2</span>.<span style="color:#a6e22e">foo</span>) <span style="color:#75715e">//true
</span></span></span></code></pre></div><p>Strings in Javascript are immutable allowing for easy comparison of equality. Objects on the other hand are mutable with many properties to compare making checking equality more complicated.</p>
<p>The strict equality operator <code>===</code> performs an efficient shallow comparison which can compare primitives easily, but won&rsquo;t try to dig into the properties of an object. Instead when applied to objects it only compares the reference of the object.</p>
<p>Objects and Arrays are the only built in mutable objects in Javascript and both are compared by reference when used with a shallow equality operator.</p>
<p>A deep equality check (value equality) for mutable objects and arrays require digging to the values within the object which can be a complex and inefficient operation. To solve this problem packages like Immer and Immutable.js have been written to enforce immutable data structures. These packages use optimization techniques like <a href="https://youtu.be/I7IdS-PbEgI">structural sharing</a> to cut down on the inefficiency of creating copies of the objects.</p>
<blockquote>
<h2 id="why-do-we-care">Why do we care?<a hidden class="anchor" aria-hidden="true" href="#why-do-we-care">#</a></h2>
<p>React is one of the most prominent and performant frameworks in web development</p>
</blockquote>
<p>The main benefits of React come from some sophisticated change detection to only update the DOM when it has to. React is unopinionated about whether you use mutable or immutable data however it can be better optimized using immutable data.
React offers a <code>PureComponent</code> along with a <code>shouldComponentUpdate()</code> method which can be easily implemented with immutable data to greatly increase performance.</p>
<p>Pure components implement the <code>shouldComponentUpdate()</code> method with a shallow prop and state comparison to decide whether to re-render the component. This shallow comparison is all that&rsquo;s needed to decide whether the data has changed since the immutable data will have a new reference if it changed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span> <span style="color:#a6e22e">shouldComponentUpdate</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">nextProps</span>, <span style="color:#a6e22e">nextState</span>){
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">shallowCompare</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">nextProps</span>, <span style="color:#a6e22e">nextState</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">shallowCompare</span>(<span style="color:#a6e22e">instance</span>, <span style="color:#a6e22e">nextProps</span>, <span style="color:#a6e22e">nextState</span>){
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">nextProps</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">props</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">nextState</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">instance</span>.<span style="color:#a6e22e">state</span>)
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>Clearly for React immutability is a net positive as in many ways it matches the way the framework thinks. Immutability <strong>can</strong> help keep an application architecture simple and make it easier to reason about however one size doesn&rsquo;t fit all.</p>
<p>Redux is a frontend state management framework designed with immutable data in mind. It takes advantage of the shallow equality checking to offer benefits like simpler programming and debugging with a ~time traveling~ debugger. Redux performs state management similar to an event sourced system where state is controlled by events (redux calls them actions) fed into reducers (pure functions with no side effects.) Event sourcing is a larger discussion coming soon ðŸ¤Œ.</p>
<blockquote>
<p>Immutability can bring increased performance to your app, and leads to simpler programming and debugging, as data that never changes is easier to reason about than data that is free to be changed arbitrarily throughout your app.<br>
-<em>Our god Dan Abramov</em></p>
</blockquote>
<p>There&rsquo;s a lot of hype surrounding immutability which is dangerous as like everything it can introduce a lot of unnecessary complexity if misused. It&rsquo;s important to consider some <a href="https://desalasworks.com/article/immutability-in-javascript-a-contrarian-view/">contrary views as well</a> and consider if it&rsquo;s worth the tradeoffs.</p>


  </div>

  <footer class="post-footer">
<nav class="paginav">
  <a class="prev" href="https://fahnestockj.com/posts/graphql_rest/">
    <span class="title">Â« Prev Page</span>
    <br>
    <span>GraphQL and REST</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://fahnestockj.com">Fahnestockj</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
